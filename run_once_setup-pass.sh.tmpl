#!/usr/bin/env bash
set -euo pipefail

# Purpose: Bootstrap pass (password-store) with GnuPG and optional git remote.
# - Installs pass + gnupg (+ pinentry)
# - Optionally imports provided GPG keys (from env)
# - Configures pinentry (macOS uses pinentry-mac)
# - Clones or initializes ~/.password-store, sets .gpg-id, enables git
# - Optionally seeds entries (e.g., key/github, key/raycast) from env
#
# This script is safe to re-run; it is idempotent and guarded.

# Configuration via environment (set before `chezmoi apply`, or the script will help scaffold safe defaults):
#   PASS_GIT_REMOTE                 # e.g. git@github.com:you/password-store.git (optional)
#   PASS_GPG_KEY_ID                 # e.g. 0xABCDEF... or full fingerprint (optional)
#   PASS_GPG_PRIVATE_KEY_B64        # base64-encoded ASCII-armored private key (optional)
#   PASS_GPG_PUBLIC_KEY_B64         # base64-encoded ASCII-armored public key (optional)
#   PASS_GPG_PRIVATE_KEY_FILE       # path to ASCII-armored private key (optional)
#   PASS_GPG_PUBLIC_KEY_FILE        # path to ASCII-armored public key (optional)
#   PASS_TRUST_KEY="1"              # if set, mark imported key as ultimately trusted
#   PASS_GIT_AUTHOR_NAME/EMAIL      # optional git identity for ~/.password-store repo
#   GITHUB_TOKEN                    # optional seed for pass insert key/github

# You can also create/edit: $HOME/.config/chezmoi/pass-bootstrap.env
# This script will source it if present and will create a template of it when missing.
#   RAYCAST_TOKEN                   # optional seed for pass insert key/raycast

command_exists() { command -v "$1" >/dev/null 2>&1; }

detect_os() {
    uname -s
}

install_deps() {
    os=$(detect_os)
    if [ "$os" = "Darwin" ]; then
        if ! command_exists brew; then
            echo "[pass-setup] Homebrew missing; install it or run repo's brew bootstrap first" >&2
            exit 0
        fi
        brew install gnupg pinentry-mac pass >/dev/null || true
    else
        # Try common package managers
        if command_exists apt-get; then
            sudo apt-get update -y >/dev/null || true
            sudo apt-get install -y --no-install-recommends gnupg2 pinentry-tty pass >/dev/null || true
        elif command_exists dnf; then
            sudo dnf install -y gnupg2 pinentry pass >/dev/null || true
        elif command_exists pacman; then
            sudo pacman --noconfirm -Syu gnupg pinentry pass >/dev/null || true
        elif command_exists zypper; then
            sudo zypper --non-interactive in gnupg2 pinentry pass >/dev/null || true
        else
            echo "[pass-setup] Unsupported package manager; please install gnupg + pass manually." >&2
        fi
    fi
}

configure_pinentry() {
    os=$(detect_os)
    mkdir -p "$HOME/.gnupg"
    chmod 700 "$HOME/.gnupg"
    if [ "$os" = "Darwin" ]; then
        if command_exists pinentry-mac; then
            grep -q '^pinentry-program ' "$HOME/.gnupg/gpg-agent.conf" 2>/dev/null || {
                echo "pinentry-program $(command -v pinentry-mac)" >> "$HOME/.gnupg/gpg-agent.conf"
            }
            gpgconf --kill gpg-agent 2>/dev/null || true
        fi
    fi
}

import_gpg_keys() {
    local imported=0
    if [ -n "${PASS_GPG_PUBLIC_KEY_B64:-}" ]; then
        echo "$PASS_GPG_PUBLIC_KEY_B64" | base64 --decode | gpg --import --batch --yes
        imported=1
    fi
    if [ -n "${PASS_GPG_PRIVATE_KEY_B64:-}" ]; then
        echo "$PASS_GPG_PRIVATE_KEY_B64" | base64 --decode | gpg --import --batch --yes
        imported=1
    fi
    if [ -n "${PASS_GPG_PUBLIC_KEY_FILE:-}" ] && [ -f "$PASS_GPG_PUBLIC_KEY_FILE" ]; then
        gpg --import --batch --yes "$PASS_GPG_PUBLIC_KEY_FILE"
        imported=1
    fi
    if [ -n "${PASS_GPG_PRIVATE_KEY_FILE:-}" ] && [ -f "$PASS_GPG_PRIVATE_KEY_FILE" ]; then
        gpg --import --batch --yes "$PASS_GPG_PRIVATE_KEY_FILE"
        imported=1
    fi
    if [ "$imported" = 1 ] && [ -n "${PASS_TRUST_KEY:-}" ]; then
        # Mark as ultimately trusted if key id is available
        if [ -n "${PASS_GPG_KEY_ID:-}" ]; then
            # Convert to fingerprint if short id
            fp=$(gpg --list-keys --with-colons "$PASS_GPG_KEY_ID" | awk -F: '/^fpr:/ {print $10; exit}')
            if [ -n "$fp" ]; then
                echo "$fp:6:" | gpg --import-ownertrust
            fi
        fi
    fi
}

derive_key_id_if_missing() {
    if [ -z "${PASS_GPG_KEY_ID:-}" ]; then
        # Take the first secret key fingerprint, if any
        local fp
        fp=$(gpg --list-secret-keys --with-colons 2>/dev/null | awk -F: '/^fpr:/ {print $10; exit}')
        if [ -n "$fp" ]; then
            export PASS_GPG_KEY_ID="$fp"
        fi
    fi
}

ensure_password_store_repo() {
    mkdir -p "$HOME/.password-store"
    if [ ! -d "$HOME/.password-store/.git" ]; then
        if [ -n "${PASS_GIT_REMOTE:-}" ]; then
            rm -rf "$HOME/.password-store" 2>/dev/null || true
            git clone "$PASS_GIT_REMOTE" "$HOME/.password-store" || {
                # Fallback: init empty repo
                mkdir -p "$HOME/.password-store"
                (cd "$HOME/.password-store" && git init -b main >/dev/null 2>&1 || git init >/dev/null)
                (cd "$HOME/.password-store" && git remote add origin "$PASS_GIT_REMOTE" 2>/dev/null || true)
            }
        else
            (cd "$HOME/.password-store" && git init -b main >/dev/null 2>&1 || git init >/dev/null)
        fi
    fi

    # Set git identity if provided
    if [ -n "${PASS_GIT_AUTHOR_NAME:-}" ]; then
        (cd "$HOME/.password-store" && git config user.name "$PASS_GIT_AUTHOR_NAME")
    fi
    if [ -n "${PASS_GIT_AUTHOR_EMAIL:-}" ]; then
        (cd "$HOME/.password-store" && git config user.email "$PASS_GIT_AUTHOR_EMAIL")
    fi
}

ensure_gpg_id_and_init() {
    if [ -z "${PASS_GPG_KEY_ID:-}" ]; then
        echo "[pass-setup] No PASS_GPG_KEY_ID found and no secret keys available; skipping pass init." >&2
        return 0
    fi
    if [ ! -f "$HOME/.password-store/.gpg-id" ]; then
        echo "$PASS_GPG_KEY_ID" > "$HOME/.password-store/.gpg-id"
    fi
    # Initialize pass for this key (will rewrite .gpg-id and re-encrypt if needed)
    if command_exists pass; then
        pass init -p "" "$PASS_GPG_KEY_ID" >/dev/null 2>&1 || pass init "$PASS_GPG_KEY_ID" >/dev/null 2>&1 || true
        (cd "$HOME/.password-store" && git add .gpg-id >/dev/null 2>&1 || true)
    fi
}

seed_entries_from_env() {
    # Only insert if env var present and entry missing
    if [ -n "${GITHUB_TOKEN:-}" ] && command_exists pass; then
        if ! pass show key/github >/dev/null 2>&1; then
            printf "%s" "$GITHUB_TOKEN" | pass insert -m key/github >/dev/null || true
        fi
    fi
    if [ -n "${RAYCAST_TOKEN:-}" ] && command_exists pass; then
        if ! pass show key/raycast >/dev/null 2>&1; then
            printf "%s" "$RAYCAST_TOKEN" | pass insert -m key/raycast >/dev/null || true
        fi
    fi
}

maybe_git_push() {
    if [ -d "$HOME/.password-store/.git" ]; then
        (cd "$HOME/.password-store" && git add -A && (git commit -m "chore(pass): bootstrap" || true) >/dev/null 2>&1)
        if [ -n "${PASS_GIT_REMOTE:-}" ]; then
            (cd "$HOME/.password-store" && git remote get-url origin >/dev/null 2>&1 && (git push -u origin HEAD || true))
        fi
    fi
}

export GPG_TTY=${GPG_TTY:-$(tty 2>/dev/null || echo "")}

# Load user overrides if present
BOOTSTRAP_ENV="$HOME/.config/chezmoi/pass-bootstrap.env"
if [ -f "$BOOTSTRAP_ENV" ]; then
    # shellcheck disable=SC1090
    . "$BOOTSTRAP_ENV"
fi

# Safe defaults (non-secret)
export PASS_GIT_AUTHOR_NAME=${PASS_GIT_AUTHOR_NAME:-"{{ .name | default "" }}"}
export PASS_GIT_AUTHOR_EMAIL=${PASS_GIT_AUTHOR_EMAIL:-"{{ .email | default "" }}"}

# Try to infer GitHub remote if not provided and gh is logged in
if [ -z "${PASS_GIT_REMOTE:-}" ] && command -v gh >/dev/null 2>&1; then
    if gh auth status >/dev/null 2>&1; then
        GH_USER=$(gh api user -q .login 2>/dev/null || true)
        if [ -n "$GH_USER" ]; then
            export PASS_GIT_REMOTE="git@github.com:${GH_USER}/password-store.git"
        fi
    fi
fi

# If still empty, leave a clearly marked placeholder (printed and scaffolded below)
PASS_GIT_REMOTE=${PASS_GIT_REMOTE:-"git@github.com:REPLACE_ME/password-store.git"}

echo "[pass-setup] Installing dependencies"
install_deps
echo "[pass-setup] Configuring pinentry"
configure_pinentry
echo "[pass-setup] Importing GPG keys (if provided)"
import_gpg_keys
derive_key_id_if_missing
echo "[pass-setup] Ensuring ~/.password-store repo"
ensure_password_store_repo
echo "[pass-setup] Initializing pass store (if key available)"
ensure_gpg_id_and_init
echo "[pass-setup] Seeding entries from env (optional)"
seed_entries_from_env
echo "[pass-setup] Finalizing git sync (if remote set)"
maybe_git_push

echo "[pass-setup] Done. If prompted by GPG, enter your key passphrase locally."

# Scaffold a helpful env file if it does not exist yet (with placeholders for you to fill in)
if [ ! -f "$BOOTSTRAP_ENV" ]; then
    mkdir -p "$(dirname "$BOOTSTRAP_ENV")"
    cat >"$BOOTSTRAP_ENV" <<'EOF'
# pass-bootstrap.env — fill in the placeholders and re-run `chezmoi apply`

# REQUIRED if you want to sync the store to GitHub (replace REPLACE_ME)
PASS_GIT_REMOTE="git@github.com:REPLACE_ME/password-store.git"   # TODO: set your GitHub username/repo

# OPTIONAL: set to your GPG key id or full fingerprint; if omitted, script will pick the first secret key
# Example: PASS_GPG_KEY_ID="AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
#PASS_GPG_KEY_ID=""

# OPTIONAL: provide your GPG keys for import (choose either *_FILE or *_B64 variants)
#PASS_GPG_PUBLIC_KEY_FILE="$HOME/path/to/pub.asc"     # TODO
#PASS_GPG_PRIVATE_KEY_FILE="$HOME/path/to/priv.asc"   # TODO
#PASS_GPG_PUBLIC_KEY_B64=""                            # TODO (base64 of ASCII-armored .asc file)
#PASS_GPG_PRIVATE_KEY_B64=""                           # TODO (base64 of ASCII-armored .asc file)

# OPTIONAL: mark imported key as ultimately trusted (set to 1)
#PASS_TRUST_KEY="1"

# OPTIONAL: set the git identity for ~/.password-store repo
PASS_GIT_AUTHOR_NAME="{{ .name | default "" }}"
PASS_GIT_AUTHOR_EMAIL="{{ .email | default "" }}"

# OPTIONAL: seed entries on first run (leave empty otherwise)
#GITHUB_TOKEN=""      # TODO: if set, seeds pass entry key/github
#RAYCAST_TOKEN=""     # TODO: if set, seeds pass entry key/raycast
EOF
    chmod 600 "$BOOTSTRAP_ENV" || true
    echo "[pass-setup] Wrote $BOOTSTRAP_ENV — review and fill in TODOs as needed."
fi
